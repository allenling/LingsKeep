变量和内存
============

**变量只是别名, 方便我们读代码而已, 本质上变量名是代表一个内存区域**


C语言中, 变量赋值只是开辟一个内存区域, 然后里面存一些数据(二进制), 然后用变量名别名一下, 但是怎么用, 就是语言(C)来处理了, **也就是你可以随意操作内存**.

比如一个8字节的内存, 里面存储了97这个二进制, 那么你可以当做int来读取前4个字节, 也就是97, 也可以当做字符来读取前1一个字节, 也就是'a'字符.


.. code-block:: c

   int a = 10;

就是为a开辟了一个内存区域, 比如a的开始地址是100, &a=100, 然后100开始之后的4个字节的内容是1, 也就是000(n个0)1.


指针修改
=============


.. code-block:: c

    int *p;
    // 指针指向a的地址
    p = &a;

    *p = 97;
    printf("%d, %d", a, *p);

这里也就是说:

1. 开辟一个大小为8字节的内存空间(因为指针都是8字节), 比如其开始地址为105

2. 然后存储的是a的地址, 所以104之后的8字节的值是100

3. 然后*p的操作就是把p指向的整数, 也就是a, 的值修改为97.

那么打印出来的就是97. 所以我们通过一个指针的方式修改了内存的值, 然后原来变量的值也随之改变了...


不同类型也也可以修改
=======================

既然是按字节来获取值的, 我们也可以把a锁存储的值当做字符来看待~~因为都是二进制数据嘛, 怎么操作都可以的了

.. code-block:: c

    char *s;
    // 下面是指针强制转换
    s = (char *)&a
    printf("s is %c\n", *s);
    *s = 'c';
    printf("%d, %c", a, *s);

第一个打印语句打印出来的是'a':

1. 因为整数a的值是97, 也就是前4个字节是97

2. 变量s赋值是: 先开辟一个内存区域, 其地址假设为113, 存储的是一个指针, 指向a, 这里先忽略指针强制转换.

3. 求\*s, 也就是求s指向的字符, 也就是求s指向的地址的开始第一个字节, 由上面可知, s指向a, a的前4个字节是97, 由于97完全可以用一个字节表示, 所以
   
   \*s也就是a的第一个字节, 也就是97, 也就是字符a的ascii码, 所以a就是97

同样的, 修改了*s之后, 也修改了a的第一个字节了, 所以第二个打印语句打印出来a也被修改为99(c的ascii码)
   


结构体也一样
================

结构体也一样, 结构体可以看做一块比较大的内存块, 然后按照定义元素的类型来划出大小:

.. code-block:: c

    typedef struct {
    	int data;
    	char name;
    	char first_name;
    }Test;

    Test *t = (Test *)malloc(sizeof(Test));
    t->data = 1;
    t->name = 'a';
    t->first_name = 'b';

上面定义了一个结构体Test, 第一个元素是data, 类型是int, 所以其前4个字节就划给了data(int), 同样的, 第五个字节则是划分给name, 第六个字节划分给first_name.

但是, 其实Test的大小(sizeof(Test))是8, 结构体的分配内存的大小有个规则, 参考一下 `这里 <http://www.cnblogs.com/0201zcr/p/4789332.html>`_


指针存储的是什么!!!!
=====================

上面说过, 变量赋值也就是开辟一个内存空间, 然后赋值上0, 1, 语言(或者编译器)根据不同的类型, 做不同处理, 比如是整型, 那么前4个字节代表的就是整数,

字符型, 前1一字节代表的是字符, 值一样, 但是不同的类型, 语言有不同的处理方式. 但是本质上都是内存和0, 1组成的值而已.


**指针类型的不同点就是, 指针存储的值是一个地址!**


.. code-block:: c

    typedef struct {
    	int data;
    	char name;
    	char first_name;
    }Test;

    Test *t = (Test *)malloc(sizeof(Test));
    t->data = 1;
    t->name = 'a';
    t->first_name = 'b';

上面定义了一个结构体Test, 大小是8字节, 然后我们用malloc分配了8字节大小的内存. 这里先忽略强制转换.

所以也就是开辟了一个大小为8字节的内存区域, 假设开始地址为200, 然后200之后的8个字节都属于结构体Test.

**而指针是一个指向就是指向改地址的一个变量**, 根据上面变量的解释, 对于指针变量t, 也就是:

*开辟一个大小为8字节的内存地址, 起始地址为500, 存储的是之前分配出来的结构体Test的地址, 也就是200*

所以data的地址是200-204, name的地址是204-205, first_name的起始地址是205-206， 后面206-208是多的2字节

.. code-block::

        t                                    结构体内存
        地址: 500, 大小: 8字节(t)            地址: 200, 大小: 8字节
        +------+                             +-------------+
        | 200  |                             | int  4字节  |
        |      |                             +-------------+
        |      |                             | char 1字节  |
        |      |                             +-------------+
        |      |                             | char 1字节  |
        |      |                             +-------------+
        |      |                             | 剩下的2字节 |
        +------+                             +-------------+


其中:

.. code-block:: c

    printf("%p\n", &t);
 

&t表示求t变量本身的地址, 就是500 

.. code-block:: c
    printf("%p", t);

由于t是指针, 所以t就直接去求t指向的地址了, 这里就是200
 
.. code-block:: 
    t->data = 1;


这里t->data = 1会执行两步:

1. 先求t保存的地址, 也就是200, 然后寻址200

2. 根据定义, data是int, 也就是data是Test的前4个字节, 所以会把200开始之后的4个字节赋值为1.



指针的强制转换!!!!
======================

**指针强制转换的本质: 内存赋值.**

.. code-block:: c

    typedef struct {
    	int data;
    	char name;
    }Test;
    
    typedef struct {
    	char name;
    }TestTwo;

    Test *t = (Test *)malloc(sizeof(Test));
    t->data = 1;
    t->name = 'a';
    TestTwo *tt = (TestTwo *)t;
    printf("%c", tt->name);


上面定义了Test和TestTwo两个结构体, 前者大小为8字节, 后者大小为1字节.

1. 先分配了一个大小为8字节的内存空间, 起始地址假设为300, 其值为结构体的地址, 假设为1000, 这就是t.

2. 然后一次位1000-1008的空间分配值

强制转换步骤为:

1. 分配一个内存空间, 起始地址假设为308

2. 然后其指向的地址是t所指向的地址, 也就是308之后的把8字节的值就是1000.


.. code-block:: 


        t                                    结构体Test内存
        地址: 300, 大小: 8字节(t)            地址: 1000, 大小: 8字节
        +------+                             +-------------+
        | 1000 |                             | int  4字节  |
        |      |                             +-------------+
        |      |                             | char 1字节  |
        |      |                             +-------------+
        |      |                             | char 1字节  |
        |      |                             +-------------+
        |      |                             | 剩下的2字节 |
        +------+                             +-------------+

        tt
        地址308, 大小8字节
        +------+
        | 1000 |
        |      |
        |      |
        |      |
        |      |
        |      |
        |      |
        +------+

然后, 求出tt->name, 其实就是: 

1. 对tt求值, 得到100， 然后寻址1000

2. 拿出name, 因为name在tt中定义的是char, 占1字节, 所以tt->name就是拿1000-1001这个字节, 作为字符打印出来.

所以打印的是01所代表的ascii字符

如果修改:

.. code-block:: c

   t->data = 256

如果t->data = 2**8 = 256

也就是第1, 2个字节为00000001 00000000(低位在后面), 那么tt->name取第一个字节就取到0了!!!


指针, 指针的类型!!!
=====================


一个从python的dict拿过来的例子, 但是代码做了修改:

.. code-block:: c

    typedef struct _object {
        int data;
    } PyObject;
    
    typedef struct {
        PyObject *ob_base;
    }PyDictObject;

    PyObject *a = (PyObject *)malloc(sizeof(PyObject));
    a->data = 1;
    PyDictObject *b = (PyDictObject *)a;
    printf("%p\n", b->ob_base);

这里定义了PyObject和PyDictObject, 由于PyDictObject中包含了PyObject, 所以python中经常先初始化一个PyObject, 然后把这个PyObject

就当做新的PyDictObject来用. **但是不管PyDictObject还是PyObject, 其本质上指向的应该是同一个内存区域.**

然后这里企图就是通过PyObject, 拿到PyDictObject进行操作, 但是失败了, b->ob_base并不是PyObject的指针, 打印出来是1, 也就是a->data的值.

失败的原因是: **强制转换之后, b把存储的值, 也就是Pyobject的地址, 当做PyDictObject, 然后b->ob_base则是取前8字节当做PyObject的地址!!!!**

1. 首先分配a, a的地址是600, 存储的PyObject地址是2000, 然后赋值2000之后4个字节为1.

2. 然后强制转换: 为变量b分配地址700, 大小8个字节, 存储a指向的地址, 也就是2000.

**我们之前预测b->ob_base应该是一个PyObject的指针, 因为觉得b存储的是一个PyDictObject的结构体, 这个结构体的开始地址是b的开始地址, 也就是700, 然后前8字节的值是2000, 是PyObject的地址.**

其实是错的, 指针存储的一定是地址!!!! **所以b存储的2000则根据声明, 会当做一个PyDictObject的地址, 所以b指向的是开始地址为2000的PyDictObject.**

所以这个时候进行b->ob_base求值的时候, 从2000开始, 取前8字节的值, 为1, 当做PyObject的地址.



.. code-block:: 

        a                                    结构体PyObject内存
        地址: 600, 大小: 8字节(t)            地址: 2000, 大小: 8字节
        +------+                             +-------------+
        | 2000 |                             | int  4字节  |
        |      |                             +-------------+
        |      |                             | char 1字节  |
        |      |                             +-------------+
        |      |                             | char 1字节  |
        |      |                             +-------------+
        |      |                             | 剩下的2字节 |
        +------+                             +-------------+

        b                                    PyDictObject                      PyObject
        地址700, 大小8字节                  地址: 2000, 大小: 8字节            地址: 1
        +------+                            +-------------+                    +-------------+
        | 2000 |                            | 1           |                    | 地址为1     |
        |      |                            |             |                    | 的内存并不  |
        |      |          b->ob_base        |             |     b->ob_base     | 是我们想要  |
        |      | ----------------------->   |             |    ------------>   | 访问的地方  |
        |      |                            |             |                    |             |
        |      |                            |             |                    |             |
        |      |                            |             |                    |             |
        +------+                            +-------------+                    +-------------+
                                                                               
所以, 要想正确强制转换, 则可以

显式存储
-------------

手动为PyDictObject分配一个内存, 然后显式赋值.

.. code-block:: c

    PyDictObject *b = (PyDictObject *)malloc(sizeof(PyDictObject));
    b->ob_base = a;

**注意的是, 不能说未对b分配内存而直接把b->ob_base给赋值, 因为不先为b分配内存, 就没有地方存储b->ob_base了**

比如这样:

.. code-block:: c

    PyDictObject *b;
    // 这样是不行滴
    b->ob_base = a;


存储为非指针(python做法)
-----------------------------

如果PyDictObject的成员是PyObject, 而不是PyObject的指针也可以, python也是这么做的.

.. code-block:: c

    typedef struct {
        PyObject ob_base;
    }PyDictObject;

    PyObject *a = (PyObject *)malloc(sizeof(PyObject));
    a->data = 1;
    PyDictObject *b = (PyDictObject *)a;
    printf("ob_base is %p, qqqq \n", &(b->ob_base));

这里, b存储的依然是2000, 然后把2000-2008地址的内存当做一个PyDictObject

**然后由于PyDictObject前8个字节是PyObject结构体, 而不是PyObject的地址!!**,

所以b->ob_base直接把前8个字节, 值为1, 当做PyObject结构体, 所以(b->ob_base).data这样就可以访问了, 这样不是把前把

前8字节当做地址, 所以b->ob_base不会去寻址!!!


当然, python中更经常的是定一个指针, 然后互指, 也就是要想通过b得到PyObject的话, 直接:

.. code-block:: c

    PyObject *tmp = (PyObject *)b;

这样tmp存储的地址就是2000, 随便修改吧.



数组/指针, 指针移动
=====================

数组指针和指针数组: `这里 <http://www.cnblogs.com/hongcha717/archive/2010/10/24/1859780.html>`_

**指针数组和数组指针的类型由最后一个名字决定的, 指针数组就是一个数组, 元素是指针, 数组指针就是一个指针, 指向一个数组**

运算优先级: () > [] > \*

指针数组
--------------

.. code-block:: c

   int *p[2];

[]先执行, 然后int \*指明数组元素的类型, 也就是p是一个数组, 里面的元素都是整型指针(也就是存储的是整型的地址), p是指针数组.

数组指针
------------

.. code-block:: c

   int (*p)[2];

也就是()先执行, p是一个指针, 指向的是一个长度为2的数组, p是数组指针. 所以 p + 1则是会跨过自己的大小, 也就是p指向的数组的长度, 也就是如果p的地址是100, 那么p+1=108

指针数组移动
---------------

指针数组的+1操作:

.. code-block:: c

    int a = 3;
    int b = 4;
    int *p[5];
    p[0] = &a;
    p[1] = &b;
    printf("%d, %d\n", *(p[0]), *(p[1]));
    printf("%d, %d\n", *(*(p)), *(*(p+1)));

上面两个输出都是3, 4.

**下标求值**

p[n]就是直接求出第n个元素的值了, 所以p[0]得到p第1个8字节的值, 也就是一个地址, p[0] = 200.

假设p的地址是100, a的地址是200, b的地址是204, 那么p的第一个8字节, p[0]=200, 第二个8字节, p[1]=204, 然后用\*操作去寻址, 所以

\*(p[0])就是先求p[0], 得到200, 然后\*操作去寻址200, 得到a的值, 也就是3, \*p[1]同理.

**如果p+1呢?**

p + n和p[n]的不同之处在于, \*(p + n) = p[n], **p + n相当于数组内地址移动, 下标运算[n]则是进行前一步的移动之后求数组元素值**

p是指针, 他的移动步长是8字节, 所以如果p的地址是100, 那么p+1就是p的地址移动8字节, 就是108, 这是一个指针类型, 其值是108, p+1相当于

tmp = p + 1, 也就是tmp是一个指针, 其地址是108.

注意的是108是一个地址, 里面存储的是b的地址, 也就是204，所以用\*号求出tmp(108)存储的值, \*tmp  = \*(p+1) = 204, 然后在用\*号寻址204, 204

是整数b的地址, 所以*204 = 4, 所以\*\*tmp = \*(\*(p+1)) = \*204 = 4;


数组指针移动
----------------


.. code-block:: c


    int (*q)[3];
    int c[3] = {100, 101, 102};
    q = &c;
    printf("%d, %d, %d", (*q)[0], (*q)[1], (*q)[2]);
    printf("%d, %d, %d", q[0][0], q[0][1], q[0][2]);

输出都是100, 101, 102.

q是一个指向长度为3的数组的指针, 所以其大小是8字节.

假设q的地址是100, c的地址是300, 那么q的值就是300. 所以求出q指向的数组\*q, 然后求出数组的第1, 2, 3个元素

(\*q)[0], (\*q)[1], (\*q)[2].

由于下标是移动求值, 所以q[0]得到的就是移动到q的开头, 然后求q第1个8字节的值, 也就是300, 根据定义, 是一个数组, 所以再下标求值就和c[0]一样了

**q+1呢?**

q + 1是得到q指向的初始地址, 再移动一个类型决定的步长.

由于q是指向指向长度为3的整型数组, 所以q + 1则会移动到3 * 4 = 12字节, 如果q的地址是100, q指向300, 那么那么q+1则是312.

**直接赋值**

例子是先声明后赋值的, 如果直接赋值呢?

.. code-block:: c

    int (*d)[1] = {5, 6};
    int (*e)[2] = {5, 6};

看起来(\*d)[0]会得到5, 但是其实去寻址内存地址为5的内存块， e也一样.

这是因为定义为指针, 那么其大小就是8字节, 存储的就应该是一个地址, 比如d的定义, 会把其后面数字作为地址值存入d的地址空间.

比如d的地址是500, 那么其8字节的值就是5, 之所以为5, 是因为右边数组会拿第一个元素作为值赋值给左边.

所以正确的赋值应该是, 指针根据一定是一个地址:

.. code-block:: c

    int c[3] = {100, 101, 102};
    int (*d)[1] = &c;

如果dd的地址是500, 其指向300, 那么d+1就是300移动4个字节, 那么d+1就是304.

移动的区别
-------------


所以数组指针和指针数组移动的区别是:

假设定义:

.. code-block:: c
    
    int a = 1; // a的地址是100
    int b =2;  // b的地址是200
    int *p[2]; // p的地址是300
    p[0] = &a;
    p[1] = &b;
 
    int c[1] = {10}; //c的地址是400
    int (*q)[3]; // q的地址是500
    q = &p;

1. 指针数组的移动是在数组内移动, p+1就是308, \*(p+1)则是对308求值, 也就是200, 这是一个指针的地址, 所以\*运算寻址\*(\*(p+1))=2, 也就是\*(p[1]) = 2

2. 数组指针则是指针指向的地址的移动, 步长由数组指针的定义觉得. q是指针, 其地址是500, 存储的是c的地址400, 所以q+1则是, 从其指向的地址400开始, 

   由其定义知道, q的大小是3 \* 4=12字节, 所以400开始移动12字节, 也就是412字节.


数组越界
---------

c语言中, 数组越界是不会报错的(gcc下, windows的不太一样), 然后数组只是方便你去访问而已, 不做限制, 所以python中经常用长度来表示list, tuple等

对象中, 数据数组的长度.


参考 `这里 <https://www.zhihu.com/question/23440081/answer/135771173>`_

PyTupleObject
====================

PyTupleObject中, 元素是保存在ob_item中

.. code-block:: c

    typedef struct {
        // 这个头包含了长度
        // size_t size;
        PyObject_VAR_HEAD
        // 长度为1的元素数组
        PyObject *ob_item[1];
    
    } PyTupleObject;


ob_item是一个长度为1的数组, 但是如果元素多于1个呢?

python中的做法就是根据长度n, 直接初始化ob_iten[0], ..., ob_item[n-1]

通过长度读取数据, 越界没关系~~~~~

PyListObject
=============

同理, PyListObject中, 存储元素是用一个PyObject指针数组, 但是其形式是一个指针的指针:

.. code-block:: c

    typedef struct {
        // 这个包含了元素个数
        // size_t size
        PyObject_VAR_HEAD
        // 指针的指针
        PyObject **ob_item;
        // 这个是list已经分配的大小
        Py_ssize_t allocated;
    } PyListObject;

遍历元素的时候, 就是遍历ob_item这个指针的指针, 根据之前说的, 指针的移动跟指针的类型有关, 

所以list.append的时候, 会直接移动赋值ob_item

这里本质上和PyObject \*ob_item[0]是一样的.

PyDictObject也一样!!

移动之后赋值冲突
===================

如果定义了一个数组, 然后越界访问, 那么越界那部分数据会不会被污染?

比如PyListObject中, 从ob_item指向的地址开始, 分配allocated个空间, 然后通过ob_item + 1的方式去访问, 但是如果其他有

程序覆盖了ob_item+1这个地址的值呢?

应该是会的, 不然别人就不会说多线程的c程序bug会在某一天的其他程序中出现, 原因是因为数组越界访问了.

但是在本地简单地试了几个小例子, 都没能出现数据污染的情况, **编译器总能根据定义赋值来预分配好了内存**~~

功力不够, 做不出来.



