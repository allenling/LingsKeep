signal
========

信号处理模块

1. 只能在主线程中使用系统调用sigaction去设置对应信号的handler, handler不是python代码, 而是c函数signal_handler, 毕竟内核又不能直接执行python代码.

2. signal_handler(实际是trip_signal函数)去设置全局Handlers这个数组中对应的信号为受信状态, 然后通知vm有信号受信.

3. 如果你自己设置了监听fd, 就是你调用signal.sets_wakeup_fd这个函数设置自己的wakup_fd, 那么signal_handler会把信号的信号码写入wakeup_fd, 这样你自己监听wakup_fd也就会被唤醒了.

4. 通知vm是通过设置runtime变量来实现的, 这样vm执行到下一个字节码的时候, 发现有待处理的调用(pendding_call), 那么去调用PyErr_CheckSignals去执行信号对应的python代码.

5. PyErr_CheckSignals会遍历全局的Handlers这个数组, 找到受信的信号, 调用对应的python代码.

6. python并不是把信号的handler加入队列, 然后一个个调用的形式, 而是受到信号之后, 尽可能的立马执行.

7. linux中signal的handler是保存到进程的, 所以使用kill发送信号的时候, 内核回去选择一个满足条件的线程去唤醒, 具体看下面.

8. linux中signal的分发: http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_04.html
   这里: https://unix.stackexchange.com/questions/225687/what-happens-to-a-multithreaded-linux-process-if-it-gets-a-signal

----


信号处理限制
==============


信号处理只能在主线程中, 不能在子线程中

cpython/Modules/signalmodule.c

下面是注释的解释

.. code-block:: c

    /*
       NOTES ON THE INTERACTION BETWEEN SIGNALS AND THREADS
    
       When threads are supported, we want the following semantics:
    
       - only the main thread can set a signal handler
       - any thread can get a signal handler
       - signals are only delivered to the main thread
    
       I.e. we don't support "synchronous signals" like SIGFPE (catching
       this doesn't make much sense in Python anyway) nor do we support
       signals as a means of inter-thread communication, since not all
       thread implementations support that (at least our thread library
       doesn't).
    
       We still have the problem that in some implementations signals
       generated by the keyboard (e.g. SIGINT) are delivered to all
       threads (e.g. SGI), while in others (e.g. Solaris) such signals are
       delivered to one random thread (an intermediate possibility would
       be to deliver it to the main thread -- POSIX?).  For now, we have
       a working implementation that works in all three cases -- the
       handler ignores signals if getpid() isn't the same as in the main
       thread.  XXX This is a hack.
    */


1. 如果定义了线程支持(一般都支持, 除非你手动取消), 那么只能在主线程中设置信号handler

2. 任何线程都可以获取一个handler

3. 如果发生了signal, 那么信号只会传递给主线程. **因为你子线程并不能设置handler嘛, 所以只能在主线程中设置, 所以嘛信号只会传递到主线程咯.**


signal.signal
================

.. code-block:: c

    static PyObject *
    signal_signal_impl(PyObject *module, int signalnum, PyObject *handler)
    /*[clinic end generated code: output=b44cfda43780f3a1 input=deee84af5fa0432c]*/
    {
    
        // 省略了一些代码

        // 如果开启了线程支持
        #ifdef WITH_THREAD
        // 如果不是主线程中设置handler, 则报错
        if (PyThread_get_thread_ident() != main_thread) {
            PyErr_SetString(PyExc_ValueError,
                            "signal only works in main thread");
            return NULL;
        }
        #endif
        if (signalnum < 1 || signalnum >= NSIG) {
            PyErr_SetString(PyExc_ValueError,
                            "signal number out of range");
            return NULL;
        }
        // 下面的if是校验传入的handler是否是callable对象
        if (handler == IgnoreHandler)
            func = SIG_IGN;
        else if (handler == DefaultHandler)
            func = SIG_DFL;
        else if (!PyCallable_Check(handler)) {
            PyErr_SetString(PyExc_TypeError,
             "signal handler must be signal.SIG_IGN, signal.SIG_DFL, or a callable object");
                    return NULL;
        }
        else
            // 这个signal_handler是统一的调用入口
            // 并不是直接把传入的handler交给系统
            // 毕竟系统又不能直接调用python代码
            func = signal_handler;
        /* Check for pending signals before changing signal handler */
        if (PyErr_CheckSignals()) {
            return NULL;
        }
        // 这里去替换掉signal默认的handler
        // 注意的是这里是第二个参数是func而不是handler
        if (PyOS_setsig(signalnum, func) == SIG_ERR) {
            PyErr_SetFromErrno(PyExc_OSError);
            return NULL;
        }
        // 替换掉当前映射的signal和对应的handler
        // 最后返回oldhandler
        old_handler = Handlers[signalnum].func;
        Py_INCREF(handler);
        Handlers[signalnum].func = handler;
        if (old_handler != NULL)
            return old_handler;
        else
            Py_RETURN_NONE;


    }

修改默认的signal的handler为signal_handler函数, 这个是统一的handler入口.

这个signal_handler是统一的调用入口, 并不是直接把传入的handler交给系统, 毕竟系统又不能直接调用python代码



PyOS_setsig
===============

这个函数是调用默认的sigaction去替换handler的

当前系统是否有sigaction系统调用取决于HAVE_SIGACTION这个宏


HAVE_SIGACTION定义在pyconfig.h

.. code-block:: c

    /* Define to 1 if you have the `sigaction' function. */
    #define HAVE_SIGACTION 1

linux下存在sigaction, sigaction的作用是改变对应signal的handler(man sigaction).

cpython/Python/pylifecycle.c

.. code-block:: c

    PyOS_sighandler_t
    PyOS_setsig(int sig, PyOS_sighandler_t handler)
    {
    // 是否有sigaction调用
    #ifdef HAVE_SIGACTION
        /* Some code in Modules/signalmodule.c depends on sigaction() being
         * used here if HAVE_SIGACTION is defined.  Fix that if this code
         * changes to invalidate that assumption.
         */
        struct sigaction context, ocontext;
        context.sa_handler = handler;
        sigemptyset(&context.sa_mask);
        context.sa_flags = 0;
        // 调用sigaction
        if (sigaction(sig, &context, &ocontext) == -1)
            return SIG_ERR;
        return ocontext.sa_handler;
    #else
        PyOS_sighandler_t oldhandler;
        oldhandler = signal(sig, handler);
    #ifdef HAVE_SIGINTERRUPT
        siginterrupt(sig, 1);
    #endif
        return oldhandler;
    #endif
    }


signal_handler
==================

这个函数嘛~~~调用trip_signal, 设置全局的Handlers这个数组中对应的信号为受信状态, 通知vm有带处理的调用


.. code-block:: c

    static void
    signal_handler(int sig_num)
    {
        int save_errno = errno;
    
        // 如果启用的线程并且当前是主线程
        #ifdef WITH_THREAD
            /* See NOTES section above */
            if (getpid() == main_pid)
        #endif
        {
            // 调用trip_signal
            trip_signal(sig_num);
        }
        
    #ifndef HAVE_SIGACTION
    #ifdef SIGCHLD
        /* To avoid infinite recursion, this signal remains
           reset until explicit re-instated.
           Don't clear the 'func' field as it is our pointer
           to the Python handler... */
        if (sig_num != SIGCHLD)
    #endif
        /* If the handler was not set up with sigaction, reinstall it.  See
         * Python/pylifecycle.c for the implementation of PyOS_setsig which
         * makes this true.  See also issue8354. */
         // 这里注意一下
        PyOS_setsig(sig_num, signal_handler);
    #endif

        /* Issue #10311: asynchronously executing signal handlers should not
           mutate errno under the feet of unsuspecting C code. */
        errno = save_errno;

    #ifdef MS_WINDOWS
        if (sig_num == SIGINT)
            SetEvent(sigint_event);
    #endif
    }

trip_signal
============

主要功能是设置全局的Handlers中对应信号为受信状态, 通知vm有待处理调用

如果你自己设置了另外一个wakeup_fd的话, 写入该wakeup_fd

.. code-block:: c

    static void
    trip_signal(int sig_num)
    {
        unsigned char byte;
        int fd;
        Py_ssize_t rc;
    
        // 设置Handlers中对应信号为受信状态
        // 注意的是, 这里一次设置一个
        _Py_atomic_store_relaxed(&Handlers[sig_num].tripped, 1);
    
        /* Set is_tripped after setting .tripped, as it gets
           cleared in PyErr_CheckSignals() before .tripped. */
        // 这里设置全局变量is_tripped为1, 方便快速检查是否有信号受信
        _Py_atomic_store(&is_tripped, 1);
    
        /* Notify ceval.c */
        // 通知vm的
        _PyEval_SignalReceived();
    
        // 这一大串注释也没怎么看懂
        /* And then write to the wakeup fd *after* setting all the globals and
           doing the _PyEval_SignalReceived. We used to write to the wakeup fd
           and then set the flag, but this allowed the following sequence of events
           (especially on windows, where trip_signal may run in a new thread):
    
           - main thread blocks on select([wakeup_fd], ...)
           - signal arrives
           - trip_signal writes to the wakeup fd
           - the main thread wakes up
           - the main thread checks the signal flags, sees that they're unset
           - the main thread empties the wakeup fd
           - the main thread goes back to sleep
           - trip_signal sets the flags to request the Python-level signal handler
             be run
           - the main thread doesn't notice, because it's asleep
    
           See bpo-30038 for more details.
        */
    
    #ifdef MS_WINDOWS
        // windows平台的代码
    #else
        // fd为wakeup_fd
        fd = wakeup_fd;
    #endif
    

        // 如果你自己设置了wakeup_fd的话
        if (fd != INVALID_FD) {
            // 也会唤醒监听wakeup_fd的线程的
            byte = (unsigned char)sig_num;
    #ifdef MS_WINDOWS
    // windows平台的代码
    #endif
            {
                // 把信号码转成byte的形式
                byte = (unsigned char)sig_num;
    
                /* _Py_write_noraise() retries write() if write() is interrupted by
                   a signal (fails with EINTR). */

                // 把信号的信号码写入fd, 也就是wakeup_fd
                rc = _Py_write_noraise(fd, &byte, 1);
    
                if (rc < 0) {
                    /* Py_AddPendingCall() isn't signal-safe, but we
                       still use it for this exceptional case. */
                    Py_AddPendingCall(report_wakeup_write_error,
                                      (void *)(intptr_t)errno);
                }
            }
        }
    }


_PyEval_SignalReceived
=========================

通知当前进程, 有待处理的调用, 是通过设置runtime变量来实现的

.. code-block:: c

    void
    _PyEval_SignalReceived(void)
    {
        /* bpo-30703: Function called when the C signal handler of Python gets a
           signal. We cannot queue a callback using Py_AddPendingCall() since
           that function is not async-signal-safe. */
        SIGNAL_PENDING_CALLS();
    }

SIGNAL_PENDING_CALLS的定义在cpython/Python/ceval.c:

设置runtime的变量

.. code-block:: c

    #define SIGNAL_PENDING_CALLS() \
        do { \
            _Py_atomic_store_relaxed(&_PyRuntime.ceval.pending.calls_to_do, 1); \
            _Py_atomic_store_relaxed(&_PyRuntime.ceval.eval_breaker, 1); \
        } while (0)

vm执行signal
================

在_PyEval_EvalFrameDefault这个执行字节码的函数中, 每次执行字节码的时候, 回去判断是否有待处理的调用(pendding call)


.. code-block:: c

    PyObject* _Py_HOT_FUNCTION
    _PyEval_EvalFrameDefault(PyFrameObject *f, int throwflag)
    {
    
        // 这个for循环就是无限执行字节码的地方
        for (;;) {
        
            // 肯定是省略了一大堆代码了
            
            // 这个就是判断上之前提到的calls_to_do变量了
            if (_Py_atomic_load_relaxed(
                        &_PyRuntime.ceval.pending.calls_to_do))
            {
            
            // 执行一下待处理调用
            if (Py_MakePendingCalls() < 0)
                goto error;
            }
        
        
        }
    
    }


Py_MakePendingCalls
========================

处理待处理调用


.. code-block:: c

    int
    Py_MakePendingCalls(void)
    {
        // 肯定省略了很多代码的啦

        /* unsignal before starting to call callbacks, so that any callback
           added in-between re-signals */
        // 这里嘛, 把待处理调用设置为0
        UNSIGNAL_PENDING_CALLS();
    
        /* Python signal handler doesn't really queue a callback: it only signals
           that a signal was received, see _PyEval_SignalReceived(). */
        // 这里就是调用信号处理函数的地方了
        if (PyErr_CheckSignals() < 0) {
            goto error;
        }

        // 肯定省略了很多代码的啦
    }

PyErr_CheckSignals
=====================

这个函数是遍历Handlers数组, 找到受信的信号, 调用对应的, signal.signal中传入的python代码 

.. code-block:: c

    int
    PyErr_CheckSignals(void) {
    
        // 校验是否是主线程
        #ifdef WITH_THREAD
            if (PyThread_get_thread_ident() != main_thread)
                return 0;
        #endif
    
        _Py_atomic_store(&is_tripped, 0);
    
        if (!(f = (PyObject *)PyEval_GetFrame()))
            f = Py_None;
    
        // 下面的for循环就是一个个去检查是哪个信号受信了
        for (i = 1; i < NSIG; i++) {
            if (_Py_atomic_load_relaxed(&Handlers[i].tripped)) {
                PyObject *result = NULL;
                PyObject *arglist = Py_BuildValue("(iO)", i, f);
                _Py_atomic_store_relaxed(&Handlers[i].tripped, 0);
    
                if (arglist) {
                    // 调用python代码
                    result = PyEval_CallObject(Handlers[i].func,
                                               arglist);
                    Py_DECREF(arglist);
                }
                if (!result) {
                    _Py_atomic_store(&is_tripped, 1);
                    return -1;
                }
    
                Py_DECREF(result);
            }
        }
    
        return 0;
    
    
    }

linux的kill
================

一般我们是用kill向进程发送信号的, 那么哪个线程被唤醒呢?

https://elixir.bootlin.com/linux/v4.15/source/kernel/signal.c#L892

.. code-block:: c

    /**
     *  sys_kill - send a signal to a process
     *  @pid: the PID of the process
     *  @sig: signal to be sent
     */
    SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)
    {
        struct siginfo info;

        info.si_signo = sig;
        info.si_errno = 0;
        info.si_code = SI_USER;
        info.si_pid = task_tgid_vnr(current);
        info.si_uid = from_kuid_munged(current_user_ns(), current_uid());

        return kill_something_info(sig, &info, pid);
    }


更具体的流程, 参考这里: http://kernel.meizu.com/linux-signal.html

pid结构参考: http://www.cnblogs.com/parrynee/archive/2010/01/14/1648152.html

**最终, 挑选线程是在complete_signal函数**

.. code-block:: c

    // https://elixir.bootlin.com/linux/v4.15/source/kernel/signal.c#L892


    static void complete_signal(int sig, struct task_struct *p, int group)
    {
        struct signal_struct *signal = p->signal;
        struct task_struct *t;

        /*
         * Now find a thread we can wake up to take the signal off the queue.
         *
         * If the main thread wants the signal, it gets first crack.
         * Probably the least surprising to the average bear.
         */
         // 注意看注释
         // 优先检查主线程
        if (wants_signal(sig, p))
            t = p;
        else if (!group || thread_group_empty(p))
            /*
             * There is just one thread and it does not need to be woken.
             * It will dequeue unblocked signals before it runs again.
             */
            return;
        else {
            /*
             * Otherwise try to find a suitable thread.
             */
             // 否则, 遍历, 找到一个可以处理信号的线程
             // 然后终止遍历
            t = signal->curr_target;
            while (!wants_signal(sig, t)) {
                t = next_thread(t);
                if (t == signal->curr_target)
                    // 这里说明循环了一圈
                    /*
                     * No thread needs to be woken.
                     * Any eligible threads will see
                     * the signal in the queue soon.
                     */
                    return;
            }
            signal->curr_target = t;
        }

        /*
         * Found a killable thread.  If the signal will be fatal,
         * then start taking the whole group down immediately.
         */
         // 如果KILL这种杀死类型的信号(fatal)
        if (sig_fatal(p, sig) &&
            !(signal->flags & SIGNAL_GROUP_EXIT) &&
            !sigismember(&t->real_blocked, sig) &&
            (sig == SIGKILL || !p->ptrace)) {
            /*
             * This signal will be fatal to the whole group.
             */
            if (!sig_kernel_coredump(sig)) {
                /*
                 * Start a group exit and wake everybody up.
                 * This way we don't have other threads
                 * running and doing things after a slower
                 * thread has the fatal signal pending.
                 */
                 // 退出所有的线程
                signal->flags = SIGNAL_GROUP_EXIT;
                signal->group_exit_code = sig;
                signal->group_stop_count = 0;
                t = p;
                do {
                    task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);
                    sigaddset(&t->pending.signal, SIGKILL);
                    signal_wake_up(t, 1);
                } while_each_thread(p, t);
                return;
            }
        }

        /*
         * The signal is already in the shared-pending queue.
         * Tell the chosen thread to wake up and dequeue it.
         */
         // 否则唤醒线程
        signal_wake_up(t, sig == SIGKILL);
        return;
    }
    
所以基本上是先判断主线程是否会处理信号, 然后去遍历, 找到第一个会去处理信号的线程, 如果没有线程想要处理信号, 直接return

wants_signal
=================

这个函数是判断一个线程是否想要处理信号

.. code-block:: c

    /*
     * Test if P wants to take SIG.  After we've checked all threads with this,
     * it's equivalent to finding no threads not blocking SIG.  Any threads not
     * blocking SIG were ruled out because they are not running and already
     * have pending signals.  Such threads will dequeue from the shared queue
     * as soon as they're available, so putting the signal on the shared queue
     * will be equivalent to sending it to one such thread.
     */
    static inline int wants_signal(int sig, struct task_struct *p)
    {
        if (sigismember(&p->blocked, sig))
            return 0;
        if (p->flags & PF_EXITING)
            return 0;
        if (sig == SIGKILL)
            return 1;
        if (task_is_stopped_or_traced(p))
            return 0;
        return task_curr(p) || !signal_pending(p);
    }

1. sigismember作用是: *test wehether signum is a member of set.(&p->blocked, sig)* , 也就是是否线程是否block了信号.
   因为线程可以调用sigprocmask/pthread_sigmask去block指定的信号, 如果结果为真, 表示线程屏蔽了信号.
   可以参考 `这里 <http://devarea.com/linux-handling-signals-in-a-multithreaded-application/#.WpAhGINuaUk>`_
   
2. PF_EXITING表示进程退出状态

3. SIGKILL这个信号是要传递给所有的线程的(这样才能达到kill的目的), 所以返回1

4. task_is_stopped_or_traced线程是否是终止状态

5. task_curr是判断当前线程是否占用cpu

6. signal_pending: 检查当前进程是否有信号处理，返回不为0表示有信号需要处理.

   参考 `这里 <http://blog.csdn.net/hitxiaotao/article/details/1479196>`_
   
